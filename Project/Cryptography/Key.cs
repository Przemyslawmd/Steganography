using System;
using System.Security.Cryptography;
using System.Text;

namespace Cryptography
{
    class Key
    {
        public static byte[] CreateKey( String password )
        {            
            byte[] basicKey = new Rfc2898DeriveBytes( password, salt, iterations ).GetBytes( keyBytes );
            return ExpandKey( basicKey );
        }

        /**************************************************************************************************/
        /**************************************************************************************************/

        private static byte[] ExpandKey( byte[] key )
        {
            byte[] expandedKey = new byte[keyBytesExpanded];
            byte[] tempWord = new byte[4];

            // Copy key to first four words (16 bytes) of expanded key
            Array.Copy( key, 0, expandedKey, 0, keyBytes );

            // Take an action for the rest part of expanded key 
            for ( int i = 16; i < keyBytesExpanded; i++ )
            {
                // Copy last word of a previous key into a temporary word
                Array.Copy( expandedKey, i - 4, tempWord, 0, 4 );

                // An action for each part of expanded key to calculate its first word
                if ( i % 16 == 0 )
                    CalculateFirstWord( expandedKey, i );

                // An action to calculate rest three words of expanded key



            }

            return expandedKey;
        }

        /***************************************************************************************************/
        /***************************************************************************************************/

        private static void RotateWord( byte[] key, int index )
        {
            byte temp = key[index];
            key[index] = key[index + 1];
            key[index + 1] = key[index + 2];
            key[index + 2] = key[index + 3];
            key[index + 3] = temp;
        }


        private static void SubByte( byte[] key, int index )
        {
            for ( int i = 0; i <= 3; i++ ) 
                key[index + i] = BaseCryptography.GetSbox( key[index + i] );
        } 

        private static void CalculateFirstWord( byte[] key, int index )
        {
            RotateWord( key, index );

            //key[index] = key[index - 16] ^ BaseCryptography( ;
            //key[index + 1];
            //key[index + 2];
            //key[index + 3];

            
            //W[j] = W[j - 4] ^ SubByte( Rot1( W[j - 1] ) ) ^ Rcon[j / 4];

            //W[j] = W[j - 4] ^ SubByte( word ) ^ Rcon[j / 4];
        }



        /*****************************************************************************************************/
        /*****************************************************************************************************/

        static byte[] rcon = new byte[255]
        {
            0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
            0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
            0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
            0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
            0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
            0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
            0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
            0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
            0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
            0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
            0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
            0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
            0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
            0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
            0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
            0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb
        };

        static readonly byte[] salt = new byte[] { 4, 32, 3, 112, 34, 11, 45, 26, 4, 34 };
        static readonly int iterations = 200;
        static readonly int keyBytes = 16;
        static readonly int keyBytesExpanded = 176;
    }
}


